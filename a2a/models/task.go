/*
 * Copyright 2025 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package models

type ResponseKind string

const (
	ResponseKindTask           ResponseKind = "task"
	ResponseKindMessage        ResponseKind = "message"
	ResponseKindArtifactUpdate ResponseKind = "artifact-update"
	ResponseKindStatusUpdate   ResponseKind = "status-update"
)

// TaskState represents the state of a task within the A2A protocol
type TaskState string

const (
	TaskStateSubmitted     TaskState = "submitted"      // Task received by server, acknowledged, but processing has not yet actively started.
	TaskStateWorking       TaskState = "working"        // Task is actively being processed by the agent.
	TaskStateInputRequired TaskState = "input-required" // Agent requires additional input from the client/user to proceed. (Task is paused)
	TaskStateCompleted     TaskState = "completed"      // Task finished successfully. (Terminal state)
	TaskStateCanceled      TaskState = "canceled"       // Task was canceled by the client or potentially by the server. (Terminal state)
	TaskStateFailed        TaskState = "failed"         // Task terminated due to an error during processing. (Terminal state)
	TaskStateRejected      TaskState = "rejected"       //Task has be rejected by the remote agent (Terminal state)
	TaskStateAuthRequired  TaskState = "auth-required"  //Authentication required from client/user to proceed. (Task is paused)
	TaskStateUnknown       TaskState = "unknown"        // The state of the task cannot be determined (e.g., task ID invalid or expired). (Effectively a terminal state from client's PoV for that ID)
)

// TaskStatus represents the status of a task
type TaskStatus struct {
	// The current lifecycle state of the task.
	State TaskState `json:"state"`
	// An optional message associated with the current status.
	// This could be a progress update from the agent, a prompt for more input,
	// a summary of the final result, or an error message.
	Message *Message `json:"message,omitempty"`
	// The date and time (UTC is STRONGLY recommended) when this status was recorded by the server.
	// Format: ISO 8601 `date-time` string (e.g., "2023-10-27T10:00:00Z").
	Timestamp string `json:"timestamp,omitempty"`
}

type Task struct {
	// A unique identifier for the task. This ID is generated by the server.
	// It should be sufficiently unique (e.g., a UUID v4).
	ID string `json:"id"`
	// Server-generated id for contextual alignment across interactions
	// Useful for maintaining context across multiple, sequential, or related tasks.
	ContextID string `json:"contextId"` // todo: how to specify related tasks...

	// The current status of the task, including its lifecycle state, an optional associated message,
	// and a timestamp.
	Status TaskStatus `json:"status"`
	// An array of outputs (artifacts) generated by the agent for this task.
	// This array can be populated incrementally, especially during streaming.
	// Artifacts represent the tangible results of the task.
	Artifacts []*Artifact `json:"artifacts,omitempty"`
	// An optional array of recent messages exchanged within this task,
	// ordered chronologically (oldest first).
	// This history is included if requested by the client via the `historyLength` parameter
	// in `TaskSendParams` or `TaskQueryParams`.
	History []*Message `json:"history,omitempty"` // todo: what's the relation between status and history?
	// Arbitrary key-value metadata associated with the task.
	// Keys SHOULD be strings; values can be any valid JSON type (string, number, boolean, array, object).
	// This can be used for application-specific data, tracing info, etc.
	Metadata map[string]any `json:"metadata,omitempty"`

	//Kind string = "task" todo
}

// todo: if add
//func (t *Task) TaskContent() *TaskContent {
//	return &TaskContent{
//		Status:    t.Status,
//		Artifacts: t.Artifacts,
//		History:   t.History,
//		Metadata:  t.Metadata,
//	}
//}

func (t *Task) isSendResponse()                 {}
func (t *Task) isSendStreamingMessageResponse() {}

type TaskContent struct {
	// The current status of the task, including its lifecycle state, an optional associated message,
	// and a timestamp.
	Status TaskStatus `json:"status"`
	// An array of outputs (artifacts) generated by the agent for this task.
	// This array can be populated incrementally, especially during streaming.
	// Artifacts represent the tangible results of the task.
	Artifacts []*Artifact `json:"artifacts,omitempty"`
	// An optional array of recent messages exchanged within this task,
	// ordered chronologically (oldest first).
	// This history is included if requested by the client via the `historyLength` parameter
	// in `TaskSendParams` or `TaskQueryParams`.
	History []*Message `json:"history,omitempty"` // todo: what's the relation between status and history?
	// Arbitrary key-value metadata associated with the task.
	// Keys SHOULD be strings; values can be any valid JSON type (string, number, boolean, array, object).
	// This can be used for application-specific data, tracing info, etc.
	Metadata map[string]any `json:"metadata,omitempty"`
}

func (t *TaskContent) EnsureRequiredFields() {
	if t == nil {
		return
	}
	if t.Status.Message != nil {
		t.Status.Message.EnsureRequiredFields()
	}
	for _, m := range t.History {
		if m != nil {
			m.EnsureRequiredFields()
		}
	}
	for _, a := range t.Artifacts {
		if a != nil {
			a.EnsureRequiredFields()
		}
	}
}

// TaskStatusUpdateEvent represents an event for task status updates
type TaskStatusUpdateEvent struct {
	// The ID of the task being updated.
	TaskID string `json:"taskId"`
	// The context id the task is associated with
	ContextID string `json:"contextId"`

	// The new status object for the task.
	Status TaskStatus `json:"status"`
	// If `true`, this `TaskStatusUpdateEvent` signifies the terminal status update for the current
	// `message/stream` interaction cycle. This means the task has reached a terminal or paused state
	// and the server does not expect to send more updates for *this specific* `stream` request.
	// The server typically closes the SSE connection after sending an event with `final: true`.
	// Default: `false` if omitted.
	Final bool `json:"final,omitempty"`
	// Arbitrary metadata for this specific status update event.
	Metadata map[string]any `json:"metadata,omitempty"`
}

func (t *TaskStatusUpdateEvent) isSendStreamingMessageResponse() {}

type TaskStatusUpdateEventContent struct {
	// The new status object for the task.
	Status TaskStatus `json:"status"`
	// If `true`, this `TaskStatusUpdateEvent` signifies the terminal status update for the current
	// `message/stream` interaction cycle. This means the task has reached a terminal or paused state
	// and the server does not expect to send more updates for *this specific* `stream` request.
	// The server typically closes the SSE connection after sending an event with `final: true`.
	// Default: `false` if omitted.
	Final bool `json:"final,omitempty"`
	// Arbitrary metadata for this specific status update event.
	Metadata map[string]any `json:"metadata,omitempty"`
}

func (t *TaskStatusUpdateEventContent) EnsureRequiredFields() {
	if t == nil {
		return
	}
	if t.Status.Message != nil {
		t.Status.Message.EnsureRequiredFields()
	}
}

func (t *TaskStatusUpdateEventContent) isResponseEvent() {}

type TaskArtifactUpdateEvent struct {
	// The ID of the task associated with the generated artifact part
	TaskID string `json:"taskId"`
	// The context id the task is associated with
	ContextID string `json:"contextId"`

	// The artifact data. This could be a complete artifact or an incremental chunk.
	// The client uses `artifact.artifactId`, append, lastChunk to correctly assemble or update the artifact on its side.
	Artifact Artifact `json:"artifact"`
	/** Indicates if this artifact appends to a previous one. Omitted if artifact is a complete artifact. */
	Append bool `json:"append,omitempty"`
	/** Indicates if this is the last chunk of the artifact. Omitted if artifact is a complete artifact. */
	LastChunk bool `json:"lastChunk,omitempty"` // todo: what's the difference between Append and LastChunk, if LastChunk means all
	// Arbitrary metadata for this specific artifact update event.
	Metadata map[string]any `json:"metadata,omitempty"`
	// type discriminator, literal value
	//Kind string = "artifact-update" todo
}

type TaskArtifactUpdateEventContent struct {
	// The artifact data. This could be a complete artifact or an incremental chunk.
	// The client uses `artifact.artifactId`, append, lastChunk to correctly assemble or update the artifact on its side.
	Artifact Artifact `json:"artifact"`
	/** Indicates if this artifact appends to a previous one. Omitted if artifact is a complete artifact. */
	Append bool `json:"append,omitempty"`
	/** Indicates if this is the last chunk of the artifact. Omitted if artifact is a complete artifact. */
	LastChunk bool `json:"lastChunk,omitempty"` // todo: what's the difference between Append and LastChunk, if LastChunk means all
	// Arbitrary metadata for this specific artifact update event.
	Metadata map[string]any `json:"metadata,omitempty"`
}

func (t *TaskArtifactUpdateEventContent) EnsureRequiredFields() {
	if t == nil {
		return
	}
	(&t.Artifact).EnsureRequiredFields()
}

type TaskQueryParams struct {
	// The ID of the task to retrieve.
	ID string `json:"id"`
	// Optional: If a positive integer `N` is provided, the server SHOULD include the last `N` messages
	// (chronologically) of the task's history in the `Task.history` field of the response.
	// If `0`, or omitted, no history is explicitly requested.
	HistoryLength *int `json:"historyLength,omitempty"`
	// Arbitrary metadata for this specific `tasks/get` request.
	Metadata map[string]any `json:"metadata,omitempty"`
}

// TaskIDParams
// used for task/cancel and tasks/pushNotificationConfig/get and tasks/resubscribe
type TaskIDParams struct {
	// The ID of the task to which the operation applies (e.g., cancel, get push notification config).
	ID string `json:"id"`
	// Arbitrary metadata for this specific request.
	Metadata map[string]any `json:"metadata,omitempty"`
}

// TaskPushNotificationConfig
// used for tasks/pushNotificationConfig/set and returned by tasks/pushNotificationConfig/get
type TaskPushNotificationConfig struct {
	// The ID of the task for which push notification settings are being configured or retrieved.
	TaskID string `json:"taskId"`
	// The push notification configuration details.
	// When used as params for `set`, this provides the configuration to apply.
	// When used as result for `get`, this reflects the currently active configuration (server MAY omit secrets).
	PushNotificationConfig PushNotificationConfig `json:"pushNotificationConfig"`
}
